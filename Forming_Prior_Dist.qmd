---
title: "Forming_Prior_Dist"
format: html
---

```{r}
library(tidyverse)
library(compr)
library(broom)
library(dplyr)
library(readr)
library(deuce)

# Source the functions
source("comp_prior_start.R")
source("bayes_intro.R")
source("wrangle_point_level_data.R")
```

We are going to look at the Alcaraz vs Djokovic 2023 Wimbledon Final. Let's include all grass court matches since the start of Wimbledon the year before in 2022.
```{r}
## reading in atp matches for 3 years
ext_vec <- c("atp_matches_2022.csv",
             "atp_matches_2023.csv")
atp_22_23 <- purrr::map(ext_vec, read_matches) |>
  bind_rows()

test <- read_matches("atp_matches_2022.csv")

# Now filter for relevant matches
atp_wimbledon_prior <- atp_22_23 |>
  mutate(tourney_date = lubridate::ymd(tourney_date)) |>
  filter(tourney_name == "Wimbledon" |
           (surface == "Grass" & tourney_date <= "2023-07-03" & tourney_date >= "2023-01-01"))
# TODO remove final from prior dist

# Put the relevant match data into point format
atp_wimbledon_points <- atp_wimbledon_prior |>
  select(1:3,6,7,9,11,17,19,24,30,32,33,39,41,42,46,48) |>
  mutate(w_svpt_w = w_1stWon + w_2ndWon,
         w_svpt_l = w_svpt - w_svpt_w,
         l_svpt_w = l_1stWon + l_2ndWon,
         l_svpt_l = l_svpt - l_svpt_w) |>
  select(winner_name, loser_name, w_svpt_w, w_svpt_l, l_svpt_w, l_svpt_l, match_num,
         1:5, 7, 9, 16:17) |>
  pivot_longer(cols = c("w_svpt_w", "w_svpt_l", "l_svpt_w", "l_svpt_l"),
                        names_to = "won_point",
                        values_to = "server") |>
  mutate(pt_winner = recode(
    won_point,
    "w_svpt_w" = 1,
    "w_svpt_l" = 0,
    "l_svpt_w" = 0,
    "l_svpt_l" = 1)) |>
  mutate(pt_server = recode(
    won_point,
    "w_svpt_w" = 1,
    "w_svpt_l" = 1,
    "l_svpt_w" = 0,
    "l_svpt_l" = 0)) |>
  # remove rows where server is NA (walkovers)
  filter(!is.na(server))

atp_wimbledon_uncount <- uncount(atp_wimbledon_points, weights = as.numeric(server)) |>
  mutate(p1_server = ifelse(pt_server == 1, 1, 0),
         p2_server = ifelse(pt_server == 0, 1, 0)) |>
  # reorganize columns
  select(winner_name, loser_name, pt_winner, p1_server, p2_server, everything()) |>
  rename(player1 = winner_name, player2 = loser_name)

# Now fit the model to your point data with serving effects
comp_mod <- comp_glm(pt_winner ~ -1, data = atp_wimbledon_uncount,
                             p1 = "player1", p2 = "player2",
                             p1_effects = ~ p1_server, p2_effects = ~ p2_server,
                             ref_player = "Milos Raonic")

# tidy the model to view its output
prior_dist_df <- comp_mod |>
  broom::tidy() |>
  print(n = Inf)
# view output
prior_dist_df |> filter(term == "`Novak Djokovic`" | term == "`Carlos Alcaraz`") 
```

Get probabilities of Djokovic winning a point while serving and while returning
```{r}
# Create data frame that has Alcaraz and Djokovic
match_data_djok <- data.frame(
  player1 = c("Novak Djokovic", "Novak Djokovic"),
  player2 = c("Carlos Alcaraz", "Carlos Alcaraz"),
  p1_server = c(1, 0),
  p2_server = c(0, 1))


# Use `augment()` to get a predicted log odds of p1 winning a point while serving and of p1 winning a point while returning.
aug_mod_djok <- aug_mod(newdata = match_data_djok, comp_mod = comp_mod)
aug_mod_djok

# probability djokovic wins a point on serve
expit(0.7624800)
# probability djokovic wins a point on return
expit(-0.5603895)
# always looking at P1 probability
```

Get probabilities of Alcaraz winning a point while serving and while returning
```{r}
# Create data frame that has Alcaraz and Djokovic
match_data_alc <- data.frame(
  player1 = c("Carlos Alcaraz", "Carlos Alcaraz"),
  player2 = c("Novak Djokovic", "Novak Djokovic"),
  p1_server = c(1, 0),
  p2_server = c(0, 1))

# Use `augment()` to get a predicted log odds of p1 winning a point while serving and of p1 winning a point while returning.
aug_mod_alc <- aug_mod(newdata = match_data_alc, comp_mod = comp_mod)
aug_mod_alc

# probability Alcaraz wins a point on serve
expit(0.5603895)
# probability Alcaraz wins a point on return
expit(-0.7624800)
```

Let's fit the Bayesian model for a single state of the match:
```{r}
library(rstanarm)
# get ALcaraz vs Djokovic point level data for the 2023 Wimbledon final
# start by getting all point data for 2023 Wimbledon

# NOTE: Player 1 is Alcaraz and Player 2 is Djokovic
both_serving_df <- wrangle_point_level(ext = "2023-wimbledon-points.csv",
                               ID = "2023-wimbledon-1701")

alcaraz_serving <- both_serving_df[[1]]
djokovic_serving <- both_serving_df[[2]]
```

Let's look right at the start of the second set tiebreak, after Djokovic has won the first set 6-1, and just held to force a second set tiebreak.
```{r}
# slice the data to the start of the second set tiebreak
match_state_df <- djokovic_serving |>
  slice(1:68) |>
  mutate(p1_server = 0,
         p2_server = 1)

# add player1 and player2 columns
# also create indicator variables that they are serving (2 columns)
match_state_df <- match_state_df |>
  mutate(player1 = "Carlos Alcaraz",
         player2 = "Novak Djokovic") |>
# also create indicator if serving player won the point
  mutate(server_won = ifelse(PointWinner == 2, 1, 0))

# original Djokovic probability
expit(0.7624800) # 0.6818919

# fit the model to the data
x <- Sys.time()
stan_glm_fit <- stan_glm(server_won ~ 1, data = match_state_df,
                         family = binomial,
                         prior_intercept = normal(0.7624800, 0.08390474),
                         seed = 123)
y <- Sys.time()
# new Djokovic probability
coef(stan_glm_fit) |> expit() # 0.6786362
```

Loop through Djokovic serving and obtain probabilities he wins a point on serve at each point in the match
```{r}
djok_niter <- djokovic_serving |> nrow()
djok_prob_store <- double()

djokovic_serving <- djokovic_serving |>
  mutate(player1 = "Carlos Alcaraz",
         player2 = "Novak Djokovic") |>
# also create indicator if serving player won the point
  mutate(server_won = ifelse(PointWinner == 2, 1, 0))

for (i in 1:djok_niter) {
  mod <- stan_glm(server_won ~ 1, data = djokovic_serving |> slice(1:i),
                         family = binomial,
                         prior_intercept = normal(0.7624800, 0.08390474),
                         seed = 123)
  djok_prob_store[i] <- coef(mod) |> expit()
}
# observe the probabilities generated
djok_prob_store
# add probabilities to the data frame
djokovic_serving <- djokovic_serving |>
  mutate(djok_wserv_prob = format(djok_prob_store, nsmall = 7))
```

Loop through Alcaraz serving and obtain probabilities he wins a point on serve at each point in the match
```{r}
alc_niter <- alcaraz_serving |> nrow()
alc_prob_store <- double()

alcaraz_serving <- alcaraz_serving |>
  mutate(player1 = "Carlos Alcaraz",
         player2 = "Novak Djokovic") |>
# also create indicator if serving player won the point
  mutate(server_won = ifelse(PointWinner == 1, 1, 0))

for (i in 1:alc_niter) {
  mod <- stan_glm(server_won ~ 1, data = alcaraz_serving |> slice(1:i),
                         family = binomial,
                         prior_intercept = normal(0.5603895, 0.08379219),
                         seed = 123)
  alc_prob_store[i] <- coef(mod) |> expit()
}
# observe all probabilities generated
alc_prob_store
# add probabilities to the data frame
alcaraz_serving <- alcaraz_serving |> 
  mutate(alc_wserv_prob = format(alc_prob_store, nsmall = 7))
```

Combine the data frames and arrange by point number
```{r}
# combine the data frames
combined_df <- bind_rows(djokovic_serving, alcaraz_serving) |>
  arrange(pt_number) |>
  select(pt_number, player1, player2, PointServer, PointWinner, server_won,
         djok_wserv_prob, alc_wserv_prob, everything())

# observe the data frame
combined_df

# observe the probabilities
combined_df |> select(djok_wserv_prob, alc_wserv_prob) |>
  print(n = 20)
```

Don't believe this is the correct way but:
```{r}
test <- data.frame(
  player1 = "Carlos Alcaraz",
  player2 = "Novak Djokovic",
  djok_serv_prob = c(.7, .65, .60, .55, .50, NA, NA, NA, NA, .65),
  alc_serv_prob = c(NA, NA, NA, NA, NA, .55, .60, .65, .70, NA))

test

test_filled <- test %>%
  fill(djok_serv_prob, alc_serv_prob, .direction = "up")

test_filled

# fill in the missing probabilities with the next known probability
combined_filled <- combined_df |>
  fill(djok_wserv_prob, alc_wserv_prob, .direction = "up")
```

```{r}

```



