---
title: "Forming_Prior_Dist"
format: html
---

```{r}
library(tidyverse)
library(compr)
library(broom)
library(dplyr)
library(readr)
library(deuce)

# Source the functions
source("comp_prior_start.R")
source("bayes_intro.R")
source("wrangle_point_level_data.R")
```

We are going to look at the Alcaraz vs Djokovic 2023 Wimbledon Final. Let's include all grass court matches since the start of Wimbledon the year before in 2022.
```{r}
## reading in atp matches for 3 years
ext_vec <- c("atp_matches_2022.csv",
             "atp_matches_2023.csv")
atp_22_23 <- purrr::map(ext_vec, read_matches) |>
  bind_rows()

test <- read_matches("atp_matches_2022.csv")

# Now filter for relevant matches
atp_wimbledon_prior <- atp_22_23 |>
  mutate(tourney_date = lubridate::ymd(tourney_date)) |>
  filter(tourney_name == "Wimbledon" |
           (surface == "Grass" & tourney_date <= "2023-07-03" & tourney_date >= "2023-01-01"))
# TODO remove final from prior dist

# Put the relevant match data into point format
atp_wimbledon_points <- atp_wimbledon_prior |>
  select(1:3,6,7,9,11,17,19,24,30,32,33,39,41,42,46,48) |>
  mutate(w_svpt_w = w_1stWon + w_2ndWon,
         w_svpt_l = w_svpt - w_svpt_w,
         l_svpt_w = l_1stWon + l_2ndWon,
         l_svpt_l = l_svpt - l_svpt_w) |>
  select(winner_name, loser_name, w_svpt_w, w_svpt_l, l_svpt_w, l_svpt_l, match_num,
         1:5, 7, 9, 16:17) |>
  pivot_longer(cols = c("w_svpt_w", "w_svpt_l", "l_svpt_w", "l_svpt_l"),
                        names_to = "won_point",
                        values_to = "server") |>
  mutate(pt_winner = recode(
    won_point,
    "w_svpt_w" = 1,
    "w_svpt_l" = 0,
    "l_svpt_w" = 0,
    "l_svpt_l" = 1)) |>
  mutate(pt_server = recode(
    won_point,
    "w_svpt_w" = 1,
    "w_svpt_l" = 1,
    "l_svpt_w" = 0,
    "l_svpt_l" = 0)) |>
  # remove rows where server is NA (walkovers)
  filter(!is.na(server))

atp_wimbledon_uncount <- uncount(atp_wimbledon_points, weights = as.numeric(server)) |>
  mutate(p1_server = ifelse(pt_server == 1, 1, 0),
         p2_server = ifelse(pt_server == 0, 1, 0)) |>
  # reorganize columns
  select(winner_name, loser_name, pt_winner, p1_server, p2_server, everything()) |>
  rename(player1 = winner_name, player2 = loser_name)

# Now fit the model to your point data with serving effects
comp_mod <- comp_glm(pt_winner ~ -1, data = atp_wimbledon_uncount,
                             p1 = "player1", p2 = "player2",
                             p1_effects = ~ p1_server, p2_effects = ~ p2_server,
                             ref_player = "Milos Raonic")

# tidy the model to view its output
prior_dist_df <- comp_mod |>
  broom::tidy() |>
  print(n = Inf)
# view output
prior_dist_df |> filter(term == "`Novak Djokovic`" | term == "`Carlos Alcaraz`") 
```

Create data frame that has Alcaraz and Djokovic
```{r}
# 2. Create a new data frame that has the players for your match of interest (two rows: one when p1 is serving, one when p2 is serving). 2X2
match_data <- data.frame(
  player1 = c("Novak Djokovic", "Novak Djokovic"),
  player2 = c("Carlos Alcaraz", "Carlos Alcaraz"),
  p1_server = c(1, 0),
  p2_server = c(0, 1))
```

Use `augment()` to get a predicted log odds of p1 winning a point while serving and of p1 winning a point while returning.
```{r}
aug_mod <- aug_mod(newdata = match_data, comp_mod = comp_mod)
aug_mod

expit(0.7624800)
expit(-0.5603895)
# always looking at P1 probability
```

Let's fit the Bayesian model for a single state of the match:
```{r}
library(rstanarm)
# get ALcaraz vs Djokovic point level data for the 2023 Wimbledon final
# start by getting all point data for 2023 Wimbledon
wimbledon23 <- readr::read_csv("2023-wimbledon-points.csv")
# filter for Alcaraz vs Djokovic match-ID
alcaraz_djokovic <- wimbledon23 |>
  dplyr::filter(match_id == "2023-wimbledon-1701") |>
  # now use SetWinner variable to change P1GamesWon and P2GamesWon to 0 for these rows
  mutate(P1GamesWon = ifelse(SetWinner != 0, 0, P1GamesWon),
         P2GamesWon = ifelse(SetWinner != 0, 0, P2GamesWon))

# check to see if P1GamesWon and P2GamesWon are 0 for all rows where SetWinner != 0
alcaraz_djokovic |> filter(SetWinner != 0)

# NOTE: Player 1 is Alcaraz and Player 2 is Djokovic
alcaraz_djokovic_condensed <- alcaraz_djokovic |>
  select(PointWinner,
         P1Score,
         P2Score,
         P1GamesWon,
         P2GamesWon,
         SetWinner,
         PointServer) |>
  mutate(P1Score = ifelse(P1Score == "AD", 4, P1Score),
         P2Score = ifelse(P2Score == "AD", 4, P2Score),
         P1PointsWon = as.numeric(P1Score),
         P2PointsWon = as.numeric(P2Score)) |>
  mutate(P1PointsWon = case_when(P1Score == 0 ~ 0,
                                 P1Score == 15 ~ 1,
                                 P1Score == 30 ~ 2,
                                 P1Score == 40 ~ 3,
                                 TRUE ~ P1PointsWon),
         P2PointsWon = case_when(P2Score == 0 ~ 0,
                                 P2Score == 15 ~ 1,
                                 P2Score == 30 ~ 2,
                                 P2Score == 40 ~ 3,
                                 TRUE ~ P2PointsWon)) |>
  mutate(pt_number = row_number())

alcaraz_djokovic_condensed |> filter(PointWinner == 0)

# create a data frame for Djokovic serving and one for Alcaraz serving
djokovic_serving <- alcaraz_djokovic_condensed |>
  filter(PointServer == 2)
alcaraz_serving <- alcaraz_djokovic_condensed |>
  filter(PointServer == 1)
```

Let's look right at the start of the second set tiebreak, after Djokovic has won the first set 6-1, and just held to force a second set tiebreak.
```{r}
# slice the data to the start of the second set tiebreak
match_state_df <- djokovic_serving |>
  slice(1:68) |>
  mutate(p1_server = 0,
         p2_server = 1)

# add player1 and player2 columns
# also create indicator variables that they are serving (2 columns)
match_state_df <- match_state_df |>
  mutate(player1 = "Carlos Alcaraz",
         player2 = "Novak Djokovic") |>
# also create indicator if serving player won the point
  mutate(server_won = ifelse(PointWinner == 2, 1, 0))

# original Djokovic probability
expit(0.532) # 0.6299495

# fit the model to the data
stan_glm_fit <- stan_glm(server_won ~ 1, data = match_state_df,
                         family = binomial,
                         prior_intercept = normal(0.532, 0.145),
                         seed = 123)
# new Djokovic probability
coef(stan_glm_fit) |> expit() # 0.6337828
```



